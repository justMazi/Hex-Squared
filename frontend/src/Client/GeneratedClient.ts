//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any);
		this.baseUrl = baseUrl ?? '';
	}

	/**
	 * @return Success
	 */
	game(id: string, size?: number, ai?: string): Promise<Game> {
		let url_ = this.baseUrl + '/api/v1/game/{id}';
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace('{id}', encodeURIComponent('' + id));

		// Add query parameters for size and AI type if provided
		let queryParams = [];
		if (size !== undefined && size !== null) {
			queryParams.push(`size=${encodeURIComponent('' + size)}`);
		}
		if (ai !== undefined && ai !== null) {
			queryParams.push(`aiType=${encodeURIComponent('' + ai)}`);
		}
		if (queryParams.length > 0) {
			url_ += `?${queryParams.join('&')}`;
		}

		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'text/plain'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGame(_response);
		});
	}

	protected processGame(response: Response): Promise<Game> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Game.fromJS(resultData200); // AiType will now be included
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<Game>(null as any);
	}

	/**
	 * @param color (optional)
	 * @return Success
	 */
	pickColor(id: string, color: number | undefined): Promise<void> {
		let url_ = this.baseUrl + '/api/v1/game/{id}/pickColor?';
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace('{id}', encodeURIComponent('' + id));
		if (color === null) throw new Error("The parameter 'color' cannot be null.");
		else if (color !== undefined) url_ += 'color=' + encodeURIComponent('' + color) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPickColor(_response);
		});
	}

	protected processPickColor(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @param q (optional)
	 * @param r (optional)
	 * @param s (optional)
	 * @return Success
	 */
	move(
		id: string,
		q: number | undefined,
		r: number | undefined,
		s: number | undefined
	): Promise<void> {
		let url_ = this.baseUrl + '/api/v1/game/{id}/move?';
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace('{id}', encodeURIComponent('' + id));
		if (q === null) throw new Error("The parameter 'q' cannot be null.");
		else if (q !== undefined) url_ += 'q=' + encodeURIComponent('' + q) + '&';
		if (r === null) throw new Error("The parameter 'r' cannot be null.");
		else if (r !== undefined) url_ += 'r=' + encodeURIComponent('' + r) + '&';
		if (s === null) throw new Error("The parameter 's' cannot be null.");
		else if (s !== undefined) url_ += 's=' + encodeURIComponent('' + s) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processMove(_response);
		});
	}

	protected processMove(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @return Success
	 */
	reset(id: string): Promise<void> {
		let url_ = this.baseUrl + '/api/v1/game/{id}/reset';
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace('{id}', encodeURIComponent('' + id));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processReset(_response);
		});
	}

	protected processReset(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @param index (optional)
	 * @return Success
	 */
	fillWithAi(id: string, index: number | undefined): Promise<void> {
		let url_ = this.baseUrl + '/api/v1/game/{id}/fill-with-ai?';
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace('{id}', encodeURIComponent('' + id));
		if (index === null) throw new Error("The parameter 'index' cannot be null.");
		else if (index !== undefined) url_ += 'index=' + encodeURIComponent('' + index) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processFillWithAi(_response);
		});
	}

	protected processFillWithAi(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}
}

export class CurrentMovePlayerIndex implements ICurrentMovePlayerIndex {
	value?: number;

	constructor(data?: ICurrentMovePlayerIndex) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.value = _data['value'];
		}
	}

	static fromJS(data: any): CurrentMovePlayerIndex {
		data = typeof data === 'object' ? data : {};
		let result = new CurrentMovePlayerIndex();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['value'] = this.value;
		return data;
	}
}

export interface ICurrentMovePlayerIndex {
	value?: number;
}
export class Game implements IGame {
	id?: GameId;
	players?: IPlayer[] | undefined;
	hexagons?: Hex[] | undefined;
	currentMovePlayerIndex?: CurrentMovePlayerIndex;
	gameState?: GameState;
	winner?: number | undefined;
	radius?: number;
	aiType?: string; // Added AiType as a string

	constructor(data?: IGame) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] ? GameId.fromJS(_data['id']) : <any>undefined;
			if (Array.isArray(_data['players'])) {
				this.players = [] as any;
				for (let item of _data['players']) this.players!.push(IPlayer.fromJS(item));
			}
			if (Array.isArray(_data['hexagons'])) {
				this.hexagons = [] as any;
				for (let item of _data['hexagons']) this.hexagons!.push(Hex.fromJS(item));
			}
			this.currentMovePlayerIndex = _data['currentMovePlayerIndex']
				? CurrentMovePlayerIndex.fromJS(_data['currentMovePlayerIndex'])
				: <any>undefined;
			this.gameState = _data['gameState'];
			this.winner = _data['winner'];
			this.radius = _data['radius'];
			this.aiType = _data['aiType']; // Initialize AiType
		}
	}

	static fromJS(data: any): Game {
		data = typeof data === 'object' ? data : {};
		let result = new Game();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id ? this.id.toJSON() : <any>undefined;
		if (Array.isArray(this.players)) {
			data['players'] = [];
			for (let item of this.players) data['players'].push(item.toJSON());
		}
		if (Array.isArray(this.hexagons)) {
			data['hexagons'] = [];
			for (let item of this.hexagons) data['hexagons'].push(item.toJSON());
		}
		data['currentMovePlayerIndex'] = this.currentMovePlayerIndex
			? this.currentMovePlayerIndex.toJSON()
			: <any>undefined;
		data['gameState'] = this.gameState;
		data['winner'] = this.winner;
		data['radius'] = this.radius;
		data['aiType'] = this.aiType; // Serialize AiType
		return data;
	}
}

export interface IGame {
	id?: GameId;
	players?: IPlayer[] | undefined;
	hexagons?: Hex[] | undefined;
	currentMovePlayerIndex?: CurrentMovePlayerIndex;
	gameState?: GameState;
	winner?: number | undefined;
	radius?: number;
	aiType?: string; // Added AiType as a string
}

export class GameId implements IGameId {
	constructor(data?: IGameId) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {}

	static fromJS(data: any): GameId {
		data = typeof data === 'object' ? data : {};
		let result = new GameId();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		return data;
	}
}

export interface IGameId {}

export enum GameState {
	_0 = 0,
	_1 = 1,
	_2 = 2
}

export class Hex implements IHex {
	r?: number;
	s?: number;
	q?: number;
	index?: number;
	owner?: number;
	readonly isTaken?: boolean;

	constructor(data?: IHex) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.r = _data['r'];
			this.s = _data['s'];
			this.q = _data['q'];
			this.index = _data['index'];
			this.owner = _data['owner'];
			(<any>this).isTaken = _data['isTaken'];
		}
	}

	static fromJS(data: any): Hex {
		data = typeof data === 'object' ? data : {};
		let result = new Hex();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['r'] = this.r;
		data['s'] = this.s;
		data['q'] = this.q;
		data['index'] = this.index;
		data['owner'] = this.owner;
		data['isTaken'] = this.isTaken;
		return data;
	}
}

export interface IHex {
	r?: number;
	s?: number;
	q?: number;
	index?: number;
	owner?: number;
	isTaken?: boolean;
}

export class IPlayer implements IIPlayer {
	readonly playerNum?: number;
	numberOfWins?: number; // Add this field

	constructor(data?: IIPlayer) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			(<any>this).playerNum = _data['playerNum'];
			this.numberOfWins = _data['numberOfWins']; // Initialize numberOfWins
		}
	}

	static fromJS(data: any): IPlayer {
		data = typeof data === 'object' ? data : {};
		let result = new IPlayer();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['playerNum'] = this.playerNum;
		data['numberOfWins'] = this.numberOfWins; // Include numberOfWins in serialization
		return data;
	}
}

export interface IIPlayer {
	playerNum?: number;
	numberOfWins?: number; // Add this field
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}
